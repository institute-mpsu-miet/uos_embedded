#ifndef _TIMEOUT_H_
#define _TIMEOUT_H_

//                              Таймауты таймера
//
//     Таймауты таймера дополняют возможности системного таймера uOS (timer_t).
// Основная идея таймаута заключается в том, что по истечении заданного
// интервала времени на мьютекс, связанный с параметром, посылается сигнал,
// позволяющий "снять" задачу с точки ожидания (mutex_wait) до наступления
// ожидаемого события.
//
//     Типовые варианты использования таймаутов:
//
// ВАРИАНТ 1. 
//    Снятие задачи с точки ожидания, если ожидаемое событие не наступило по
// прошествии заданного интервала времени.
//    Предположим, что задача ожидает сигнала (например, от прерывания) на 
// некотором мьютексе. Если сигнал не пришёл в течении 100 мс, то задача должна
// сняться с точки ожидания и обработать ошибку: таймаут.
//    Приблизительный код для реализации описанного поведения приведён ниже:
//      
//      mutex_t mutex;
//      timer_t timer;
//      timeout_t timeout;
//
//      ...
//
//      // Инициализация (например, в функции uos_init() или начале задачи).
//      timeout_init (&timeout, &timer, &mutex);
// 
//      ...
//
//      // Использование:
//      const unsigned TIMEOUT_SIGNAL = 0xFFFFFFFF; // Здесь любое число, 
//                                                  // отличное от 0.
//      timeout_set_value (&timeout, 100);          // Таймаут через 100 мс.
//
//      // Устанавливаем значение сигнала, который придёт на мьютекс в случае
//      // таймаута:
//      timeout_set_signal (&timeout, (void *) TIMEOUT_SIGNAL);
//
//      // Занимаем мьютекс, чтобы не было разрыва между запуском таймаута и 
//      // началом ожидания. Если мьютекс уже занят, делать этого не надо.
//      mutex_lock (&mutex);
//
//      // Запускаем таймер таймаута
//      timeout_start (&timeout);
//
//      // Ожидаем события на мьютексе
//      if (mutex_wait (&mutex) == (void *) TIMEOUT_SIGNAL) {
//          // Произошёл таймаут - далее его обработка
//          ...
//      } else {
//          // Произошло ожидаемое событие. Функция mutex_wait возвращает 
//          // значение, переданное во втором параметре функции mutex_signal()
//          // (mutex_activate()). Как правило, это ноль.
//          
//          timeout_stop (&timeout);
//          // Далее обработка события:
//          ...
//      }
//      
//      mutex_unlock (&mutex);
//
//    Недостатком реализации таймаутов является то, что если задача была 
// вытеснена в момент между вызовами функций timeout_start() и mutex_wait(),
// то время на ожидание события сокращается на время вытеснения. Это
// необходимо учитывать при разработке. Но это не большое ограничение, так
// как подразумевается, что интервал таймаута существенно превышает типичное
// время ожидания события.
//    Кроме того, необходимо учитывать, что объект таймаута отсчитывает
// выделенное ему время по таймеру, указанному в параметре функции 
// timeout_init(). Этот таймер имеет заданный период следования тиков (в
// параметре функции timer_init()). Точность таймаута всегда не выше этого
// периода, и действительное время таймаута всегда кратно этому периоду с 
// округлением в большую сторону при необходимости.
//
// ВАРИАНТ 2.
//    Периодические сигналы на указанный мьютекс.
//    На обычном таймере в общем случае нельзя сделать фиксированную длину цикла
// активации задачи. Например, рассмотрим следующее тело задачи:
//
//      void task (void *arg)
//      {
//          for (;;) {
//              do_work();
//              timer_delay(&timer, 10);
//          }
//      }
//
//    Длина цикла этой задачи зависит от времени выполнения функции do_work().
// Длина цикла = время(do_work) + 10 мс. Если время выполнения do_work меньше
// периода тиков таймера timer, то длительность всего цикла задачи может
// получиться равной 10 мс, но данный способ слишком ненадёжен, если нужно
// обеспечить строго 10-миллисекундный цикл.
//    Для решения этой проблемы можно использовать таймауты с установленным
// параметров autoreload. Пример кода:
//
//      mutex_t mutex;
//      timer_t timer;
//      timeout_t timeout;
//
//      ...
//
//      // Инициализация (например, в функции uos_init() или начале задачи).
//      timer_init (&timer, 2);                     // Период системного таймера
//                                                  // должен быть меньше
//                                                  // времени таймаута.
//      timeout_init (&timeout, &timer, &mutex);
//      timeout_set_value (&timeout, 10);           // Длина периода 10 мс.
//                                                  // Чтобы периоды были
//                                                  // равными, нужно, чтобы
//                                                  // длина периода была кратна
//                                                  // периоду таймера.
//      timeout_set_autoreload (&timeout, 1);       // (!)Периодический таймаут.
//
//      ...
//
//      // Использование:
//      void task (void *arg)
//      {
//          mutex_lock (&mutex);
//          timeout_start (&timeout);
//          for (;;) {
//              mutex_wait (&mutex);
//              do_work();
//          }
//      }
//
// ВАРИАНТ 3.
//    Реализация функции задержки.
//    Имеет смысл использовать объекты таймаутов данным образом только для
// реализации микросекундных задержек. Это будет работать только если включено
// глобальное макроопределение USEC_TIMER, таймер проинициализирован с помощью
// функции timer_init_us(). Задержка задаётся с помощью timeout_set_value_us().
//
//    Дополнительно объекты таймаутов имеют возможность подключения функции-
// обработчика.



#ifdef __cplusplus
extern "C" {
#endif

typedef struct _timeout_t timeout_t;

// Прототип функции-обработчика таймаута.
typedef void (* timeout_handler)(timeout_t *to, void *arg);

struct _timeout_t
{
    list_t item;
    
    timer_t *timer;
    
    mutex_t *mutex;
    void *signal;
    
    timeout_handler handler;
    void *handler_arg;
    
    unsigned long interval;
    unsigned long cur_time;
    
    int autoreload;
};

//
// Инициализация объекта таймаута.
//
// to       - объект таймаута;
// timer    - объект таймера, по которому отсчитывается таймаут;
// mutex    - мьютекс, на который придёт сигнал в случае срабатывания таймаута.
//
void timeout_init (timeout_t *to, timer_t *timer, mutex_t *mutex);

//
// Установка сигнала таймаута
//
// to       - объект таймаута;
// signal   - значение сигнала, который придёт на мьютекс при срабатывании 
//            таймаута.
//
void timeout_set_signal (timeout_t *to, void *signal);

//
// Установка периода таймаута в миллисекундах.
//
// to               - объект таймаута;
// interval_msec    - период в мс.
//
void timeout_set_value (timeout_t *to, unsigned long interval_msec);

//
// Установка периода таймаута в микросекундах.
//
// to               - объект таймаута;
// interval_usec    - период в мкс.
//
void timeout_set_value_us (timeout_t *to, unsigned long interval_usec);

//
// Установка параметра автоматического перезапуска таймаута.
//
// to               - объект таймаута;
// autoreload       - ненулевое значение означает, что таймаут будет
//                    автоматически перезапускаться по его истечении.
//
void timeout_set_autoreload (timeout_t *to, int autoreload);

//
// Установка функции-обработчика таймаута.
//
// to               - объект таймаута;
// handler          - функция-обработчик;
// arg              - значение параметра функции-обработчика.
//
void timeout_set_handler (timeout_t *to, timeout_handler handler, void *arg);

//
// Запуск отсчёта таймаута.
//
// to               - объект таймаута.
//
void timeout_start (timeout_t *to);

//
// Останов отсчёта таймаута.
//
// to               - объект таймаута.
//
void timeout_stop (timeout_t *to);

#ifdef __cplusplus
}
#endif

#endif
