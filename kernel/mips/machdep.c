/*
 * Machine-dependent part of uOS for MIPS32: Elvees Multicore.
 *
 * Copyright (C) 2008-2010 Serge Vakulenko, <serge@vak.ru>
 *
 * This file is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You can redistribute this file and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software Foundation;
 * either version 2 of the License, or (at your discretion) any later version.
 * See the accompanying file "COPYING.txt" for more details.
 *
 * As a special exception to the GPL, permission is granted for additional
 * uses of the text contained in this file.  See the accompanying file
 * "COPY-UOS.txt" for details.
 */
#include "runtime/lib.h"
#include "kernel/uos.h"
#include "kernel/internal.h"

/*
 * Perform the task switch.
 * The call is performed via the assembler label,
 * to skip the function prologue, generated by the compiler.
 */
void
_arch_task_switch_ ()
{
	register task_t *target __asm ("v0");

	/* Save all registers in stack. */
	asm volatile (
"arch_task_switch: .globl arch_task_switch");
	asm volatile ("move	%0, $a0" : "=r" (target));

	asm volatile ("addi	$sp, $sp, -%0" : : "i" (CONTEXT_WORDS * 4 + MIPS_FSPACE));
	asm volatile (".set	noat");
	asm volatile ("sw	$1, %0 ($sp)" : : "i" (CONTEXT_R1 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$2, %0 ($sp)" : : "i" (CONTEXT_R2 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$3, %0 ($sp)" : : "i" (CONTEXT_R3 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$4, %0 ($sp)" : : "i" (CONTEXT_R4 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$5, %0 ($sp)" : : "i" (CONTEXT_R5 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$6, %0 ($sp)" : : "i" (CONTEXT_R6 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$7, %0 ($sp)" : : "i" (CONTEXT_R7 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$8, %0 ($sp)" : : "i" (CONTEXT_R8 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$9, %0 ($sp)" : : "i" (CONTEXT_R9 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$10, %0 ($sp)" : : "i" (CONTEXT_R10 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$11, %0 ($sp)" : : "i" (CONTEXT_R11 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$12, %0 ($sp)" : : "i" (CONTEXT_R12 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$13, %0 ($sp)" : : "i" (CONTEXT_R13 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$14, %0 ($sp)" : : "i" (CONTEXT_R14 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$15, %0 ($sp)" : : "i" (CONTEXT_R15 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$16, %0 ($sp)" : : "i" (CONTEXT_R16 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$17, %0 ($sp)" : : "i" (CONTEXT_R17 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$18, %0 ($sp)" : : "i" (CONTEXT_R18 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$19, %0 ($sp)" : : "i" (CONTEXT_R19 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$20, %0 ($sp)" : : "i" (CONTEXT_R20 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$21, %0 ($sp)" : : "i" (CONTEXT_R21 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$22, %0 ($sp)" : : "i" (CONTEXT_R22 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$23, %0 ($sp)" : : "i" (CONTEXT_R23 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$24, %0 ($sp)" : : "i" (CONTEXT_R24 * 4 + MIPS_FSPACE));
	asm volatile ("sw	$25, %0 ($sp)" : : "i" (CONTEXT_R25 * 4 + MIPS_FSPACE));
	/* Skip $26 - K0*/
	/* Skip $27 - K1*/
	asm volatile ("sw	$28, %0 ($sp)" : : "i" (CONTEXT_GP * 4 + MIPS_FSPACE));
	/* Skip $29 - SP*/
	asm volatile ("sw	$30, %0 ($sp)" : : "i" (CONTEXT_FP * 4 + MIPS_FSPACE));
	asm volatile ("sw	$31, %0 ($sp)" : : "i" (CONTEXT_RA * 4 + MIPS_FSPACE));
	asm volatile (".set	at");

	/* Save special registers. */
	asm volatile ("mfhi	$a0" : : : "a0");
	asm volatile ("sw	$a0, %0 ($sp)" : : "i" (CONTEXT_HI * 4 + MIPS_FSPACE));

	asm volatile ("mflo	$a0" : : : "a0");
	asm volatile ("sw	$a0, %0 ($sp)" : : "i" (CONTEXT_LO * 4 + MIPS_FSPACE));

	asm volatile ("mfc0	$a0, $%0" : : "i" (C0_STATUS) : "a0");
	asm volatile ("sw	$a0, %0 ($sp)" : : "i" (CONTEXT_STATUS * 4 + MIPS_FSPACE));

	asm volatile ("sw	$ra, %0 ($sp)" : : "i" (CONTEXT_PC * 4 + MIPS_FSPACE));

	asm volatile (
"switch_task:");

#ifdef ARCH_HAVE_FPU
	if (task_current->fpu_state != ~0) {
		/* Save FPU state. */
		task_current->fpu_state = mips_read_fpu_control (C1_FCSR);

		asm volatile ("addi	$sp, $sp, -%0" : : "i" (32 * 4));
		asm volatile ("sdc1	$0, %0 ($sp)" : : "i" (0 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$2, %0 ($sp)" : : "i" (2 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$4, %0 ($sp)" : : "i" (4 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$6, %0 ($sp)" : : "i" (6 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$8, %0 ($sp)" : : "i" (8 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$10, %0 ($sp)" : : "i" (10 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$12, %0 ($sp)" : : "i" (12 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$14, %0 ($sp)" : : "i" (14 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$16, %0 ($sp)" : : "i" (16 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$18, %0 ($sp)" : : "i" (18 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$20, %0 ($sp)" : : "i" (20 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$22, %0 ($sp)" : : "i" (22 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$24, %0 ($sp)" : : "i" (24 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$26, %0 ($sp)" : : "i" (26 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$28, %0 ($sp)" : : "i" (28 * 4 + MIPS_FSPACE));
		asm volatile ("sdc1	$30, %0 ($sp)" : : "i" (30 * 4 + MIPS_FSPACE));
	}
#endif
	/* Save current task stack. */
	task_current->stack_context = mips_get_stack_pointer ();

	task_current = target;

	/* Switch to the new task. */
	mips_set_stack_pointer (task_current->stack_context);

#ifdef ARCH_HAVE_FPU
	if (task_current->fpu_state != ~0) {
		/* Restore FPU state. */
		asm volatile ("ldc1	$0, %0 ($sp)" : : "i" (0 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$2, %0 ($sp)" : : "i" (2 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$4, %0 ($sp)" : : "i" (4 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$6, %0 ($sp)" : : "i" (6 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$8, %0 ($sp)" : : "i" (8 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$10, %0 ($sp)" : : "i" (10 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$12, %0 ($sp)" : : "i" (12 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$14, %0 ($sp)" : : "i" (14 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$16, %0 ($sp)" : : "i" (16 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$18, %0 ($sp)" : : "i" (18 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$20, %0 ($sp)" : : "i" (20 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$22, %0 ($sp)" : : "i" (22 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$24, %0 ($sp)" : : "i" (24 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$26, %0 ($sp)" : : "i" (26 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$28, %0 ($sp)" : : "i" (28 * 4 + MIPS_FSPACE));
		asm volatile ("ldc1	$30, %0 ($sp)" : : "i" (30 * 4 + MIPS_FSPACE));
		asm volatile ("addi	$sp, $sp, %0" : : "i" (32 * 4));

		mips_write_fpu_control (C1_FCSR, task_current->fpu_state);
	}
#endif
	/* Restore registers. */
	asm volatile (".globl _restore_regs_");
	asm volatile ("j _restore_regs_");
}

#ifdef PIC32MX
static void dump_of_death (unsigned int context[])
{
	unsigned int cause, badvaddr, config;
	const char *code = 0;

	debug_printf ("\n\n*** 0x%08x: exception ", context [CONTEXT_PC]);

	cause = mips_read_c0_register (C0_CAUSE);
	switch (cause & CA_EXC_CODE) {
	case CA_Int:	code = "Interrupt"; break;
	case CA_AdEL:	code = "Address Load"; break;
	case CA_AdES:	code = "Address Save"; break;
	case CA_IBE:	code = "Bus fetch"; break;
	case CA_DBE:	code = "Bus load/store"; break;
	case CA_Sys:	code = "Syscall"; break;
	case CA_Bp:	code = "Breakpoint"; break;
	case CA_RI:	code = "Reserved Instruction"; break;
	case CA_CPU:	code = "Coprocessor Unusable"; break;
	case CA_Ov:	code = "Arithmetic Overflow"; break;
	case CA_Tr:	code = "Trap"; break;
	}
	if (code)
		debug_printf ("'%s'\n", code);
	else
		debug_printf ("%d\n", cause >> 2 & 31);

	badvaddr = mips_read_c0_register (C0_BADVADDR);
	config = mips_read_c0_register (C0_CONFIG);
	debug_printf ("*** cause=0x%08x, badvaddr=0x%08x, config=0x%08x\n",
		cause, badvaddr, config);

	debug_printf ("                t0 = %8x   s0 = %8x   t8 = %8x   lo = %8x\n",
		context [CONTEXT_R8], context [CONTEXT_R16],
		context [CONTEXT_R24], context [CONTEXT_LO]);
	debug_printf ("at = %8x   t1 = %8x   s1 = %8x   t9 = %8x   hi = %8x\n",
		context [CONTEXT_R1], context [CONTEXT_R9], context [CONTEXT_R17],
		context [CONTEXT_R25], context [CONTEXT_HI]);
	debug_printf ("v0 = %8x   t2 = %8x   s2 = %8x               status = %8x\n",
		context [CONTEXT_R2], context [CONTEXT_R10],
		context [CONTEXT_R18], context [CONTEXT_STATUS]);
	debug_printf ("v1 = %8x   t3 = %8x   s3 = %8x                  epc = %8x\n",
		context [CONTEXT_R3], context [CONTEXT_R11],
		context [CONTEXT_R19], context [CONTEXT_PC]);
	debug_printf ("a0 = %8x   t4 = %8x   s4 = %8x   gp = %8x\n",
		context [CONTEXT_R4], context [CONTEXT_R12],
		context [CONTEXT_R20], context [CONTEXT_GP]);
	debug_printf ("a1 = %8x   t5 = %8x   s5 = %8x   sp = %8x\n",
		context [CONTEXT_R5], context [CONTEXT_R13],
		context [CONTEXT_R21], context + CONTEXT_WORDS);
	debug_printf ("a2 = %8x   t6 = %8x   s6 = %8x   fp = %8x\n",
		context [CONTEXT_R6], context [CONTEXT_R14],
		context [CONTEXT_R22], context [CONTEXT_FP]);
	debug_printf ("a3 = %8x   t7 = %8x   s7 = %8x   ra = %8x\n",
		context [CONTEXT_R7], context [CONTEXT_R15],
		context [CONTEXT_R23], context [CONTEXT_RA]);

	debug_printf ("\nHalt...\n\n");
	asm volatile ("1: j 1b; nop");
}

/*
 * Translate interrupt vector number to IRQ mask.
 */
static const unsigned mask_by_vector [ARCH_INTERRUPTS] = {
	(1 << PIC32_IRQ_CT),		/* 0  - Core Timer Interrupt */
	(1 << PIC32_IRQ_CS0),           /* 1  - Core Software Interrupt 0 */
	(1 << PIC32_IRQ_CS1),           /* 2  - Core Software Interrupt 1 */
	(1 << PIC32_IRQ_INT0),          /* 3  - External Interrupt 0 */
	(1 << PIC32_IRQ_T1),            /* 4  - Timer1 */
	(1 << PIC32_IRQ_IC1),           /* 5  - Input Capture 1 */
	(1 << PIC32_IRQ_OC1),           /* 6  - Output Compare 1 */
	(1 << PIC32_IRQ_INT1),          /* 7  - External Interrupt 1 */
	(1 << PIC32_IRQ_T2),            /* 8  - Timer2 */
	(1 << PIC32_IRQ_IC2),           /* 9  - Input Capture 2 */
	(1 << PIC32_IRQ_OC2),           /* 10 - Output Compare 2 */
	(1 << PIC32_IRQ_INT2),          /* 11 - External Interrupt 2 */
	(1 << PIC32_IRQ_T3),            /* 12 - Timer3 */
	(1 << PIC32_IRQ_IC3),           /* 13 - Input Capture 3 */
	(1 << PIC32_IRQ_OC3),           /* 14 - Output Compare 3 */
	(1 << PIC32_IRQ_INT3),          /* 15 - External Interrupt 3 */
	(1 << PIC32_IRQ_T4),            /* 16 - Timer4 */
	(1 << PIC32_IRQ_IC4),           /* 17 - Input Capture 4 */
	(1 << PIC32_IRQ_OC4),           /* 18 - Output Compare 4 */
	(1 << PIC32_IRQ_INT4),          /* 19 - External Interrupt 4 */
	(1 << PIC32_IRQ_T5),            /* 20 - Timer5 */
	(1 << PIC32_IRQ_IC5),           /* 21 - Input Capture 5 */
	(1 << PIC32_IRQ_OC5),           /* 22 - Output Compare 5 */
	(1 << PIC32_IRQ_SPI1E) |        /* 23 - SPI1 */
	(1 << PIC32_IRQ_SPI1TX) |
	(1 << PIC32_IRQ_SPI1RX),
	(1 << PIC32_IRQ_U1E) |          /* 24 - UART1 */
	(1 << PIC32_IRQ_U1RX),          /* Do not add TX here! */
	(1 << PIC32_IRQ_I2C1B) |        /* 25 - I2C1 */
	(1 << PIC32_IRQ_I2C1S) |
	(1 << PIC32_IRQ_I2C1M),
	(1 << (PIC32_IRQ_CN-32)),       /* 26 - Input Change Interrupt */
	(1 << (PIC32_IRQ_AD1-32)),      /* 27 - ADC1 Convert Done */
	(1 << (PIC32_IRQ_PMP-32)),      /* 28 - Parallel Master Port */
	(1 << (PIC32_IRQ_CMP1-32)),     /* 29 - Comparator Interrupt */
	(1 << (PIC32_IRQ_CMP2-32)),     /* 30 - Comparator Interrupt */
	(1 << (PIC32_IRQ_SPI2E-32)) |   /* 31 - SPI2 */
	(1 << (PIC32_IRQ_SPI2TX-32)) |
	(1 << (PIC32_IRQ_SPI2RX-32)),
	(1 << (PIC32_IRQ_U2E-32)) |     /* 32 - UART2 */
	(1 << (PIC32_IRQ_U2RX-32)),     /* Do not add TX here! */
	(1 << (PIC32_IRQ_I2C2B-32)) |   /* 33 - I2C2 */
	(1 << (PIC32_IRQ_I2C2S-32)) |
	(1 << (PIC32_IRQ_I2C2M-32)),
	(1 << (PIC32_IRQ_FSCM-32)),     /* 34 - Fail-Safe Clock Monitor */
	(1 << (PIC32_IRQ_RTCC-32)),     /* 35 - Real-Time Clock and Calendar */
	(1 << (PIC32_IRQ_DMA0-32)),     /* 36 - DMA Channel 0 */
	(1 << (PIC32_IRQ_DMA1-32)),     /* 37 - DMA Channel 1 */
	(1 << (PIC32_IRQ_DMA2-32)),     /* 38 - DMA Channel 2 */
	(1 << (PIC32_IRQ_DMA3-32)),     /* 39 - DMA Channel 3 */
	0,				/* 40 */
	0,				/* 41 */
	0,				/* 42 */
	0,				/* 43 */
	(1 << (PIC32_IRQ_FCE-32)),      /* 44 - Flash Control Event */
	(1 << (PIC32_IRQ_USB-32)),      /* 45 - USB */
};
#endif /* PIC32MX */

/*
 * Interrupt handler.
 * The call is performed via the assembler label,
 * to skip the function prologue, generated by the compiler.
 */
void
_arch_interrupt_ (void)
{
	mutex_irq_t *h;
	int irq;

	/* Мы входим в функцию минуя пролог, созданный компилятором.
	 * Это делается, чтобы избежать избыточного сохранения регистров и
	 * расходования места в стеке. */
	asm volatile (
"_irq_handler_: .globl _irq_handler_"
	);
	
#ifdef PIC32MX
	/* Only interrupts are allowed. Any exception is fatal. */
	unsigned cause = mips_read_c0_register (C0_CAUSE);
	if ((cause & 0x0000007c) != CA_Int)
		dump_of_death (mips_get_stack_pointer () - 4);
//debug_printf ("[%08x] ", cause);
#endif

#ifdef ELVEES_FPU_EPC_BUG
	/* Исправляем ошибку в процессоре MC-24RT3: требуется откат
	 * адреса EPC, если прерывание произошло в слоте перехода
	 * команд BC1T/BC1F. При этом признак BD в регистре Cause
	 * не установлен. */
	unsigned *sp = mips_get_stack_pointer ();
	unsigned epc = sp[CONTEXT_PC+4] - 4;
	if ((*(unsigned*)epc & 0xffe00000) == 0x45000000) {
		/* Была команда перехода FPU - откатываемся. */
		sp[CONTEXT_PC+4] = epc;
	}
#endif
	for (;;) {
		/* Get the current irq number */
#ifdef PIC32MX
		unsigned intstat = INTSTAT;
//debug_printf ("{%08x} ", intstat);
		if ((intstat & PIC32_INTSTAT_SRIPL_MASK) == 0) {
			break;
                }
		irq = PIC32_INTSTAT_VEC (intstat);
//debug_printf ("i%d ", irq);

		/* Disable the irq, to avoid loops */
		unsigned mask = mask_by_vector [irq];
		if (irq == 24) {
		        if (U1STA & PIC32_USTA_TRMT)
                                mask |= 1 << PIC32_IRQ_U1TX;
		} else if (irq == 32) {
		        if (U2STA & PIC32_USTA_TRMT)
                                mask |= 1 << (PIC32_IRQ_U2TX-32);
                }
                if (irq < PIC32_VECT_CN) {
			IECCLR(0) = mask;
			IFSCLR(0) = mask;
		} else {
			IECCLR(1) = mask;
			IFSCLR(1) = mask;
                }
#endif
#ifdef MALTA
		unsigned status = mips_read_c0_register (C0_STATUS);
		unsigned cause = mips_read_c0_register (C0_CAUSE);
        unsigned pending = status & cause & 0xff00;
        if (! pending)
            break;
        irq = 23 - mips_count_leading_zeroes (pending);
		status &= ~(0x100 << (irq & 7));
		mips_write_c0_register (C0_STATUS, status);
#endif
#ifdef ELVEES
		unsigned status = mips_read_c0_register (C0_STATUS);
		unsigned cause = mips_read_c0_register (C0_CAUSE);
		unsigned pending = status & cause & 0xff00;
		if (! pending)
			break;
#endif /* ELVEES */
#if defined(ELVEES_MC24) || defined(ELVEES_MC0226)
		/* Read readme-mc24.txt for interrupt numbers. */
		if (pending & ST_IM_MCU) {
			/* Internal interrupt: 0..31. */
			irq = 31 - mips_count_leading_zeroes (MC_QSTR & MC_MASKR);
			if (irq < 0)
				break;
			/* Disable the internal irq, to avoid loops */
			MC_MASKR &= ~(1 << irq);
		} else {
			/* External irq: 32..38. */
			irq = 55 - mips_count_leading_zeroes (pending);
			/* Disable the external irq, to avoid loops */
			status &= ~(0x100 << (irq & 7));
			mips_write_c0_register (C0_STATUS, status);
		}
#endif
#ifdef ELVEES_MC24R2
		/* Read readme-mc24r2.txt for interrupt numbers. */
		if (pending & ST_IM_COMPARE) {
			/* Use number 19 for COMPARE interrupt. */
			irq = 19;
			status &= ~ST_IM_COMPARE;
			mips_write_c0_register (C0_STATUS, status);
		} else if (pending & ST_IM_QSTR0) {
			/* QSTR0 interrupt: 0..22. */
			irq = 31 - mips_count_leading_zeroes (MC_QSTR0 & MC_MASKR0);
			if (irq < 0)
				break;
			MC_MASKR0 &= ~(1 << irq);
		} else if (pending & ST_IM_QSTR1) {
			/* QSTR1 interrupt: 23..26. */
			irq = 23 + 31 - mips_count_leading_zeroes (MC_QSTR1 & MC_MASKR1);
			if (irq < 23)
				break;
			MC_MASKR1 &= ~(1 << (irq - 23));
		} else if (pending & ST_IM_QSTR2) {
			/* QSTR2 interrupt: 27..58. */
			irq = 27 + 31 - mips_count_leading_zeroes (MC_QSTR2 & MC_MASKR2);
			if (irq < 27)
				break;
			MC_MASKR2 &= ~(1 << (irq - 27));
		} else if (pending & ST_IM_QSTR3) {
			/* QSTR3 interrupt: 59..63. */
			irq = 59 + 31 - mips_count_leading_zeroes (MC_QSTR3 & MC_MASKR3);
			if (irq < 59)
				break;
			MC_MASKR3 &= ~(1 << (irq - 59));
		} else
			break;
#endif
#ifdef ELVEES_NVCOM01
		/* Read readme-nvcom01.txt for interrupt numbers. */
		if (pending & ST_IM_COMPARE) {
			/* Use number 30 for COMPARE interrupt. */
			irq = 30;
			status &= ~ST_IM_COMPARE;
			mips_write_c0_register (C0_STATUS, status);
		} else if (pending & ST_IM_SW0) {
		    irq = 28;
			status &= ~ST_IM_SW0;
			mips_write_c0_register (C0_STATUS, status);
		} else if (pending & ST_IM_SW1) {
		    irq = 29;
			status &= ~ST_IM_SW1;
			mips_write_c0_register (C0_STATUS, status);
		} else if (pending & ST_IM_QSTR0) {
			/* QSTR0 interrupt: 0..31. */
			irq = 31 - mips_count_leading_zeroes (MC_QSTR0 & MC_MASKR0);
			if (irq < 0)
				break;
			MC_MASKR0 &= ~(1 << irq);
		} else if (pending & ST_IM_QSTR1) {
			/* QSTR1 interrupt: 32..35. */
			irq = 32 + 31 - mips_count_leading_zeroes (MC_QSTR1 & MC_MASKR1);
			if (irq < 32)
				break;
			MC_MASKR1 &= ~(1 << (irq - 32));
		} else if (pending & ST_IM_QSTR2) {
			/* QSTR2 interrupt: 36..51. */
			irq = 36 + 31 - mips_count_leading_zeroes (MC_QSTR2 & MC_MASKR2);
			if (irq < 36)
				break;
			MC_MASKR2 &= ~(1 << (irq - 36));
		} else
			break;
#endif
#ifdef ELVEES_NVCOM02
		/* TODO */
		/* Read readme-nvcom02.txt for interrupt numbers. */
		if (pending & ST_IM_COMPARE) {
			/* Use number 30 for COMPARE interrupt. */
			irq = 30;
			status &= ~ST_IM_COMPARE;
			mips_write_c0_register (C0_STATUS, status);
		} else if (pending & ST_IM_QSTR0) {
			/* QSTR0 interrupt: 0..31. */
			irq = 31 - mips_count_leading_zeroes (MC_QSTR0 & MC_MASKR0);
			if (irq < 0)
				break;
			MC_MASKR0 &= ~(1 << irq);
		} else if (pending & ST_IM_QSTR1) {
			/* QSTR1 interrupt: 32..35. */
			irq = 32 + 31 - mips_count_leading_zeroes (MC_QSTR1 & MC_MASKR1);
			if (irq < 32)
				break;
			MC_MASKR1 &= ~(1 << (irq - 32));
		} else if (pending & ST_IM_QSTR2) {
			/* QSTR2 interrupt: 36..51. */
			irq = 36 + 31 - mips_count_leading_zeroes (MC_QSTR2 & MC_MASKR2);
			if (irq < 36)
				break;
			MC_MASKR2 &= ~(1 << (irq - 36));
		} else
			break;
#endif
#ifdef ELVEES_MCT02
		/* Read readme-mct02.txt for interrupt numbers. */
		if (pending & ST_IM_COMPARE) {
			/* Use number 19 for COMPARE interrupt. */
			irq = 19;
			status &= ~ST_IM_COMPARE;
			mips_write_c0_register (C0_STATUS, status);
		} else if (pending & ST_IM_QSTR0) {
			/* QSTR0 interrupt: 0..22. */
			irq = 31 - mips_count_leading_zeroes (MC_QSTR0 & MC_MASKR0);
			if (irq < 0)
				break;
			MC_MASKR0 &= ~(1 << irq);
		} else if (pending & ST_IM_QSTR1) {
			/* QSTR1 interrupt: 23..30. */
			irq = 23 + 31 - mips_count_leading_zeroes (MC_QSTR1 & MC_MASKR1);
			if (irq < 23)
				break;
			MC_MASKR1 &= ~(1 << (irq - 23));
		} else if (pending & ST_IM_QSTR2) {
			/* QSTR2 interrupt: 31..62. */
			irq = 31 + 31 - mips_count_leading_zeroes (MC_QSTR2 & MC_MASKR2);
			if (irq < 31)
				break;
			MC_MASKR2 &= ~(1 << (irq - 31));
		} else if (pending & ST_IM_QSTR3) {
			/* QSTR3 interrupt: 63..67. */
			irq = 63 + 31 - mips_count_leading_zeroes (MC_QSTR3 & MC_MASKR3);
			if (irq < 63)
				break;
			MC_MASKR3 &= ~(1 << (irq - 63));
		} else if (pending & ST_IM_QSTR4) {
			/* QSTR4 interrupt: 68..97. */
			irq = 68 + 31 - mips_count_leading_zeroes (MC_QSTR4 & MC_MASKR4);
			if (irq < 68)
				break;
			MC_MASKR4 &= ~(1 << (irq - 68));
		} else
			break;
#endif
#ifdef ELVEES_MCT03P
		/* Read readme-mct02.txt for interrupt numbers. */
		if (pending & ST_IM_COMPARE) {
			/* Use number 19 for COMPARE interrupt. */
			irq = 19;
			status &= ~ST_IM_COMPARE;
			mips_write_c0_register (C0_STATUS, status);
		} else if (pending & ST_IM_QSTR0) {
			/* QSTR0 interrupt: 0..22. */
			irq = 31 - mips_count_leading_zeroes (MC_QSTR0 & MC_MASKR0);
			if (irq < 0)
				break;
			MC_MASKR0 &= ~(1 << irq);
		} else if (pending & ST_IM_QSTR1) {
			/* QSTR1 interrupt: 23..34. */
			irq = 23 + 31 - mips_count_leading_zeroes (MC_QSTR1 & MC_MASKR1);
			if (irq < 23)
				break;
			MC_MASKR1 &= ~(1 << (irq - 23));
		} else if (pending & ST_IM_QSTR2) {
			/* QSTR2 interrupt: 35..66. */
			irq = 35 + 31 - mips_count_leading_zeroes (MC_QSTR2 & MC_MASKR2);
			if (irq < 35)
				break;
			MC_MASKR2 &= ~(1 << (irq - 35));
		} else if (pending & ST_IM_QSTR3) {
			/* QSTR3 interrupt: 67..74. */
			irq = 67 + 31 - mips_count_leading_zeroes (MC_QSTR3 & MC_MASKR3);
			if (irq < 67)
				break;
			MC_MASKR3 &= ~(1 << (irq - 67));
		} else if (pending & ST_IM_QSTR4) {
			/* QSTR4 interrupt: 75..88. */
			irq = 75 + 31 - mips_count_leading_zeroes (MC_QSTR4 & MC_MASKR4);
			if (irq < 75)
				break;
			MC_MASKR4 &= ~(1 << (irq - 75));
		} else
			break;
#endif
#ifdef ELVEES_MC0428
		/* Read readme-mc0428.txt for interrupt numbers. */
		if (pending & ST_IM_COMPARE) {
			/* Use number 24 for COMPARE interrupt. */
			irq = 24;
			status &= ~ST_IM_COMPARE;
			mips_write_c0_register (C0_STATUS, status);
		} else if (pending & ST_IM_QSTR0) {
			/* QSTR0 interrupt: 0..24. */
			irq = 31 - mips_count_leading_zeroes (MC_QSTR0 & MC_MASKR0);
			if (irq < 0)
				break;
			MC_MASKR0 &= ~(1 << irq);
		} else if (pending & ST_IM_QSTR1) {
			/* QSTR1 interrupt: 25..40. */
			irq = 25 + 31 - mips_count_leading_zeroes (MC_QSTR1 & MC_MASKR1);
			if (irq < 25)
				break;
			MC_MASKR1 &= ~(1 << (irq - 25));
		} else if (pending & ST_IM_QSTR2) {
			/* QSTR2 interrupt: 41..56. */
			irq = 41 + 31 - mips_count_leading_zeroes (MC_QSTR2 & MC_MASKR2);
			if (irq < 41)
				break;
			MC_MASKR2 &= ~(1 << (irq - 41));
		} else if (pending & ST_IM_QSTR3) {
			/* QSTR3 interrupt: 57..88. */
			irq = 57 + 31 - mips_count_leading_zeroes (MC_QSTR3 & MC_MASKR3);
			if (irq < 57)
				break;
			MC_MASKR3 &= ~(1 << (irq - 57));
		} else
			break;
#endif
#ifdef ELVEES_MC30SF6
		if (pending & ST_IM_COMPARE) {
			/* Use number 90 for COMPARE interrupt. */
			irq = 90;
			status &= ~ST_IM_COMPARE;
			mips_write_c0_register (C0_STATUS, status);
		} else if (pending & ST_IM_QSTR0) {
			/* QSTR0 interrupt: 0..30. */
			irq = 31 - mips_count_leading_zeroes (MC_QSTR0 & MC_MASKR0);
			if (irq < 0)
				break;
			MC_MASKR0 &= ~(1 << irq);
		} else if (pending & ST_IM_QSTR1) {
			/* QSTR1 interrupt: 31..46. */
			irq = 31 + 31 - mips_count_leading_zeroes (MC_QSTR1 & MC_MASKR1);
			if (irq < 31)
				break;
			MC_MASKR1 &= ~(1 << (irq - 31));
		} else if (pending & ST_IM_QSTR2) {
			/* QSTR2 interrupt: 47..73. */
			irq = 47 + 31 - mips_count_leading_zeroes (MC_QSTR2 & MC_MASKR2);
			if (irq < 47)
				break;
			MC_MASKR2 &= ~(1 << (irq - 47));
		} else if (pending & ST_IM_QSTR3) {
			/* QSTR3 interrupt: 73..105. */
			irq = 73 + 31 - mips_count_leading_zeroes (MC_QSTR3 & MC_MASKR3);
			if (irq < 73)
				break;
			MC_MASKR3 &= ~(1 << (irq - 73));
		} else
			break;
#endif
		if (irq >= ARCH_INTERRUPTS)
			break;

		h = &mutex_irq [irq];
		if (! h->lock)
			continue;

		if (h->handler) {
			/* If the lock is free -- call fast handler. */
			if (h->lock->master) {
				/* Lock is busy -- remember pending irq.
				 * Call fast handler later, in mutex_unlock(). */
				h->pending = 1;
				continue;
			}
			if ((h->handler) (h->arg) != 0) {
				/* The fast handler returns 1 when it fully
				 * serviced an interrupt. In this case
				 * there is no need to wake up the interrupt
				 * servicing task, stopped on mutex_wait.
				 * Task switching is not performed. */
				continue;
			}
		}

		/* Signal the interrupt handler, if any. */
		mutex_activate (h->lock, 0);
	}

	/* LY: copy a few lines of code from task_schedule() here. */
	if (task_need_schedule)	{
		task_t *t;

		task_need_schedule = 0;
		t = task_policy ();
		if (t != task_current) {
			t->ticks++;
			asm volatile ("move $v0, %0" : : "r" (t) : "v0");
			asm volatile ("j switch_task");
		}
	}

	/* Restore registers. */
	asm volatile (".globl _restore_regs_");
	asm volatile ("j _restore_regs_");
}

/*
 * Allow the given hardware interrupt,
 * unmasking it in the interrupt controller.
 */
void
arch_intr_allow (int irq)
{
#ifdef PIC32MX
	if (irq < PIC32_VECT_CN)
		IECSET(0) = mask_by_vector [irq];
	else
		IECSET(1) = mask_by_vector [irq];
//debug_printf ("<%d> ", irq);
#endif
#ifdef MALTA
	unsigned status = mips_read_c0_register (C0_STATUS);
	status |= (0x100 << (irq & 7));
	mips_write_c0_register (C0_STATUS, status); 
#endif
#if defined (ELVEES_MC24) || defined (ELVEES_MC0226)
	if (irq < 32) {
		/* Internal interrupt: 0..31. */
		MC_MASKR |= 1 << irq;
	} else {
		/* External irq: 32..38. */
		unsigned status = mips_read_c0_register (C0_STATUS);
		status |= 0x100 << (irq & 7);
		mips_write_c0_register (C0_STATUS, status);
	}
#endif
#ifdef ELVEES_MC24R2
	if (irq == 19) {
		/* Use irq number 19 for COMPARE interrupt. */
		unsigned status = mips_read_c0_register (C0_STATUS);
		status |= ST_IM_COMPARE;
		mips_write_c0_register (C0_STATUS, status);
	} else if (irq < 23) {
		/* QSTR0 interrupt: 0..22. */
		MC_MASKR0 |= 1 << irq;
	} else if (irq < 27) {
		/* QSTR1 interrupt: 23..26. */
		MC_MASKR1 |= 1 << (irq-23);
	} else if (irq < 59) {
		/* QSTR2 interrupt: 27..58. */
		MC_MASKR2 |= 1 << (irq-27);
	} else {
		/* QSTR3 interrupt: 59..63. */
		MC_MASKR3 |= 1 << (irq-59);
	}
#endif
#ifdef ELVEES_NVCOM01
	if (irq == 30) {
		/* Use irq number 30 for COMPARE interrupt. */
		unsigned status = mips_read_c0_register (C0_STATUS);
		status |= ST_IM_COMPARE;
		mips_write_c0_register (C0_STATUS, status);
	} else if (irq == 28) {
		unsigned status = mips_read_c0_register (C0_STATUS);
		status |= ST_IM_SW0;
		mips_write_c0_register (C0_STATUS, status);
	} else if (irq == 29) {
		unsigned status = mips_read_c0_register (C0_STATUS);
		status |= ST_IM_SW1;
		mips_write_c0_register (C0_STATUS, status);	    
	} else if (irq < 32) {
		/* QSTR0 interrupt: 0..31. */
		MC_MASKR0 |= 1 << irq;
	} else if (irq < 32+4) {
		/* QSTR1 interrupt: 32..35. */
		MC_MASKR1 |= 1 << (irq-32);
	} else {
		/* QSTR2 interrupt: 36..51. */
		MC_MASKR2 |= 1 << (irq-36);
	}
#endif
#ifdef ELVEES_NVCOM02
	/* TODO */
	if (irq == 30) {
		/* Use irq number 30 for COMPARE interrupt. */
		unsigned status = mips_read_c0_register (C0_STATUS);
		status |= ST_IM_COMPARE;
		mips_write_c0_register (C0_STATUS, status);
	} else if (irq < 32) {
		/* QSTR0 interrupt: 0..31. */
		MC_MASKR0 |= 1 << irq;
	} else if (irq < 32+4) {
		/* QSTR1 interrupt: 32..35. */
		MC_MASKR1 |= 1 << (irq-32);
	} else {
		/* QSTR2 interrupt: 36..51. */
		MC_MASKR2 |= 1 << (irq-36);
	}
#endif
#ifdef ELVEES_MCT02
	if (irq == 19) {
		/* Use irq number 19 for COMPARE interrupt. */
		unsigned status = mips_read_c0_register (C0_STATUS);
		status |= ST_IM_COMPARE;
		mips_write_c0_register (C0_STATUS, status);
	} else if (irq < 23) {
		/* QSTR0 interrupt: 0..22. */
		MC_MASKR0 |= 1 << irq;
	} else if (irq < 31) {
		/* QSTR1 interrupt: 23..30. */
		MC_MASKR1 |= 1 << (irq-23);
	} else if (irq < 63) {
		/* QSTR2 interrupt: 31..62. */
		MC_MASKR2 |= 1 << (irq-31);
	} else if (irq < 68) {
		/* QSTR3 interrupt: 63..67. */
		MC_MASKR3 |= 1 << (irq-63);
	} else {
		/* QSTR4 interrupt: 68..97. */
		MC_MASKR4 |= 1 << (irq-68);
	}
#endif
#ifdef ELVEES_MCT03P
	if (irq == 19) {
		/* Use irq number 19 for COMPARE interrupt. */
		unsigned status = mips_read_c0_register (C0_STATUS);
		status |= ST_IM_COMPARE;
		mips_write_c0_register (C0_STATUS, status);
	} else if (irq < 23) {
		/* QSTR0 interrupt: 0..22. */
		MC_MASKR0 |= 1 << irq;
	} else if (irq < 31) {
		/* QSTR1 interrupt: 23..30. */
		MC_MASKR1 |= 1 << (irq-23);
	} else if (irq < 63) {
		/* QSTR2 interrupt: 31..62. */
		MC_MASKR2 |= 1 << (irq-31);
	} else if (irq < 68) {
		/* QSTR3 interrupt: 63..67. */
		MC_MASKR3 |= 1 << (irq-63);
	} else {
		/* QSTR4 interrupt: 68..97. */
		MC_MASKR4 |= 1 << (irq-68);
	}
#endif
#ifdef ELVEES_MC0428
	if (irq == 24) {
		/* Use irq number 24 for COMPARE interrupt. */
		unsigned status = mips_read_c0_register (C0_STATUS);
		status |= ST_IM_COMPARE;
		mips_write_c0_register (C0_STATUS, status);
	} else if (irq < 25) {
		/* QSTR0 interrupt: 0..24. */
		MC_MASKR0 |= 1 << irq;
	} else if (irq < 41) {
		/* QSTR1 interrupt: 25..40. */
		MC_MASKR1 |= 1 << (irq-25);
	} else if (irq < 57) {
		/* QSTR2 interrupt: 41..56. */
		MC_MASKR2 |= 1 << (irq-41);
	} else if (irq < 89) {
		/* QSTR3 interrupt: 57..88. */
		MC_MASKR3 |= 1 << (irq-57);
	}
#endif
#ifdef ELVEES_MC30SF6
	if (irq == 90) {
		/* Use irq number 90 for COMPARE interrupt. */
		unsigned status = mips_read_c0_register (C0_STATUS);
		status |= ST_IM_COMPARE;
		mips_write_c0_register (C0_STATUS, status);
	} else if (irq < 31) {
		/* QSTR0 interrupt: 0..30. */
		MC_MASKR0 |= 1 << irq;
	} else if (irq < 47) {
		/* QSTR1 interrupt: 31..46. */
		MC_MASKR1 |= 1 << (irq-31);
	} else if (irq < 74) {
		/* QSTR2 interrupt: 47..73. */
		MC_MASKR2 |= 1 << (irq-47);
	} else {
		/* QSTR3 interrupt: 74..105. */
		MC_MASKR3 |= 1 << (irq-74);
	}
#endif
}

/*
 * Build the initial task's stack frame.
 * Arguments:
 * t	   - task object
 * func	   - function to call
 * arg	   - argument of function
 * stacksz - size of stack space
 */
void
arch_build_stack_frame (task_t *t, void (*func) (void*), void *arg,
	unsigned stacksz)
{
	unsigned i, *sp = (unsigned*) ((char*) t + stacksz);
	//extern void _gp;
	extern unsigned char _gp;

	if ((unsigned) sp & 4)
		*--sp = 0;		/* align of double word boundary */
	*--sp = 0;			/* 16 bytes of frame space: arg4 */
	*--sp = 0;			/* arg3 */
	*--sp = 0;			/* arg2 */
	*--sp = 0;			/* arg1 */
	*--sp = (unsigned) func;	/* epc - callee address */
	*--sp = ST_IE;			/* enable interrupts */
	*--sp = 0;			/* hi */
	*--sp = 0;			/* lo */
	*--sp = 0;			/* ra */
	*--sp = 0;			/* fp */
	*--sp = (unsigned) &_gp;	/* gp */
	*--sp = 0;			/* r25 */
	*--sp = 0;			/* r24 */
	*--sp = 0;			/* r23 */
	*--sp = 0;			/* r22 */
	*--sp = 0;			/* r21 */
	*--sp = 0;			/* r20 */
	*--sp = 0;			/* r19 */
	*--sp = 0;			/* r18 */
	*--sp = 0;			/* r17 */
	*--sp = 0;			/* r16 */
	*--sp = 0;			/* r15 */
	*--sp = 0;			/* r14 */
	*--sp = 0;			/* r13 */
	*--sp = 0;			/* r12 */
	*--sp = 0;			/* r11 */
	*--sp = 0;			/* r10 */
	*--sp = 0;			/* r9 */
	*--sp = 0;			/* r8 */
	*--sp = 0;			/* r7 */
	*--sp = 0;			/* r6 */
	*--sp = 0;			/* r5 */
	*--sp = (unsigned) arg;		/* r4 - task argument */
	*--sp = 0;			/* r3 */
	*--sp = 0;			/* r2 */
	*--sp = 0;			/* r1 */
	for (i=0; i<MIPS_FSPACE; i+=4)
		*--sp = 0;		/* args and locals */
	t->stack_context = (void*) sp;	/* must be at 8-byte boundary */

#ifdef ARCH_HAVE_FPU
	t->fpu_state = ARCH_FPU_STATE;	/* FPU disabled */
#endif
#ifdef ENABLE_DCACHE
	/* Flush data cache. */
        MC_CSR |= MC_CSR_FLUSH_D;
#endif
}

#ifdef ARCH_HAVE_FPU
/*
 * Control modes of float point coprocessor.
 * Return a previous mode of FPU.
 * Setting of new mode is permitted only for current task.
 * Called with interrupts disabled.
 */
unsigned int
arch_fpu_control (task_t *t, unsigned int mode, unsigned int mask)
{
	unsigned int old;

	/* Get current FPU mode. */
	if (t == task_current)
		old = mips_read_fpu_control (C1_FCSR);
	else
		old = t->fpu_state;

	if (mask != 0) {
		/* Change FPU state. */
		if (t != task_current && old == ~0) {
			debug_printf ("task_fpu_control: enabling FPU is allowed only for current task\n");
			uos_halt (1);
		}
		mode |= old & ~mask;
		if (t == task_current)
			mips_write_fpu_control (C1_FCSR, mode);
		t->fpu_state = mode;
	}

	/* Return previous mode. */
	return old;
}
#endif
