/*
 * Machine-dependent part of uOS for MSP430.
 *
 * Copyright (C) 2009 Serge Vakulenko, <serge@vak.ru>
 *
 * This file is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You can redistribute this file and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software Foundation;
 * either version 2 of the License, or (at your discretion) any later version.
 * See the accompanying file "COPYING.txt" for more details.
 *
 * As a special exception to the GPL, permission is granted for additional
 * uses of the text contained in this file.  See the accompanying file
 * "COPY-UOS.txt" for details.
 */
#include "runtime/lib.h"
#include "kernel/uos.h"
#include "kernel/internal.h"

/*
 * Build the initial task's stack frame.
 * Arguments:
 * t	   - task object
 * func	   - function to call
 * arg	   - argument of function
 * stacksz - size of stack space
 */
void
arch_build_stack_frame (task_t *t, void (*func) (void*), void *arg,
	unsigned stacksz)
{
	unsigned *sp = (unsigned*) ((char*) t + stacksz);

	*--sp = (unsigned) func;	/* pc - callee address */
	*--sp = msp430_read_sr() | GIE;	/* enable interrupts */
	*--sp = 0;			/* r4 */
	*--sp = 0;			/* r5 */
	*--sp = 0;			/* r6 */
	*--sp = 0;			/* r7 */
	*--sp = 0;			/* r8 */
	*--sp = 0;			/* r9 */
	*--sp = 0;			/* r10 */
	*--sp = 0;			/* r11 */
	*--sp = 0;			/* r12 */
	*--sp = 0;			/* r13 */
	*--sp = 0;			/* r14 */
	*--sp = (unsigned) arg;		/* r15 - task argument */
	t->stack_context = (void*) sp;
}

/*
 * Save all registers in stack.
 */
#define SAVE_REGS() asm volatile (	\
	"	push r4 \n"		\
	"	push r5 \n"		\
	"	push r6 \n"		\
	"	push r7 \n"		\
	"	push r8 \n"		\
	"	push r9 \n"		\
	"	push r10 \n"		\
	"	push r11 \n"		\
	"	push r12 \n"		\
	"	push r13 \n"		\
	"	push r14 \n"		\
	"	push r15"		\
	);

/*
 * Perform the task switch.
 */
void __attribute__((naked))
arch_task_switch (task_t *target)
{
	/* Save status register. */
	asm volatile ("push r2");
	SAVE_REGS ();

	/* Save current task stack. */
	task_current->stack_context = msp430_get_stack_pointer ();

	task_current = target;

	/* Switch to the new task. */
	msp430_set_stack_pointer (task_current->stack_context);

	/* Restore registers. */
	asm volatile (
"_restore_regs_: \n"
	"	pop	r15 \n"
	"	pop	r14 \n"
	"	pop	r13 \n"
	"	pop	r12 \n"
	"	pop	r11 \n"
	"	pop	r10 \n"
	"	pop	r9 \n"
	"	pop	r8 \n"
	"	pop	r7 \n"
	"	pop	r6 \n"
	"	pop	r5 \n"
	"	pop	r4 \n"
	"	reti"
	);
}

/*
 * Interrupt handler.
 * The call is performed via the assembler label,
 * to skip the function prologue, generated by the compiler.
 */
void __attribute__((naked))
_irq_handler_ (mutex_irq_t *h)
{
/*debug_putchar (0, '<'); debug_putchar (0, 'A' + h->irq); debug_putchar (0, '>');*/
	if (h->handler) {
		/* If the lock is free -- call fast handler. */
		if (h->lock->master) {
			/* Lock is busy -- remember pending irq.
			 * Call fast handler later, in mutex_unlock(). */
			h->pending = 1;
			asm volatile ("jmp _restore_regs_");
		}
		if ((h->handler) (h->arg) != 0) {
			/* The fast handler returns 1 when it fully
			 * serviced an interrupt. In this case
			 * there is no need to wake up the interrupt
			 * servicing task, stopped on mutex_wait.
			 * Task switching is not performed. */
			asm volatile ("jmp _restore_regs_");
		}
	}

	/* Signal the interrupt handler, if any. */
	mutex_activate (h->lock, 0);

	/* LY: copy a few lines of code from task_schedule() here. */
	if (task_need_schedule)	{
		task_t *t;

		task_need_schedule = 0;
		t = task_policy ();
		if (t != task_current) {
			task_current->stack_context = msp430_get_stack_pointer ();
			task_current = t;
			t->ticks++;
			msp430_set_stack_pointer (t->stack_context);
		}
	}

	/* Restore registers. */
	asm volatile ("jmp _restore_regs_");
}

/*
 * Shadowed interrupt masks.
 */
int _msp430_p1ie;
int _msp430_p2ie;
int _msp430_adc12ie;

/*
 * Allow the given hardware interrupt,
 * unmasking it in the interrupt controller.
 */
void
arch_intr_allow (int irq)
{
/*debug_printf ("intr_allow (%d)\n", irq);*/
	switch (irq) {
/*
 * I/O ports.
 */
#ifdef PORT1_VECTOR
        case PORT1_VECTOR/2: P1IE = _msp430_p1ie; break;	/* Port 1 */
#endif
#ifdef PORT2_VECTOR
        case PORT2_VECTOR/2: P2IE = _msp430_p2ie; break;	/* Port 2 */
#endif

/*
 * UARTs.
 */
#ifdef USART1TX_VECTOR
        case USART1TX_VECTOR/2: /*U1IE |= UTXIE1;*/ break;	/* USART 1 Transmit */
#endif
#ifdef USART1RX_VECTOR
        case USART1RX_VECTOR/2: U1IE |= URXIE1; break;		/* USART 1 Receive */
#endif
#ifdef USART0TX_VECTOR
        case USART0TX_VECTOR/2: /*U0IE |= UTXIE0;*/ break;	/* USART 0 Transmit */
#endif
#ifdef USART0RX_VECTOR
        case USART0RX_VECTOR/2: U0IE |= URXIE0; break;		/* USART 0 Receive */
#endif
#ifdef USCIAB0TX_VECTOR
        case USCIAB0TX_VECTOR/2: /*IE2 |= UCA0TXIE;*/ break;	/* USCI A0/B0 Transmit */
#endif
#ifdef USCIAB0RX_VECTOR
        case USCIAB0RX_VECTOR/2: IE2 |= UCA0RXIE; break;	/* USCI A0/B0 Receive */
#endif
#ifdef USCIAB1TX_VECTOR
        case USCIAB1TX_VECTOR/2: /*IE2 |= UCA1TXIE;*/ break;	/* USCI A1/B1 Transmit */
#endif
#ifdef USCIAB1RX_VECTOR
        case USCIAB1RX_VECTOR/2: IE2 |= UCA1RXIE; break;	/* USCI A1/B1 Receive */
#endif
#ifdef USCIA0_RXTX_VECTOR
        case USCIA0_RXTX_VECTOR/2: UCA0IE |= UCRXIE; break;	/* USCI A0 RX/TX */
#endif
#ifdef USCIB0_RXTX_VECTOR
        case USCIB0_RXTX_VECTOR/2: UCB0IE |= UCRXIE; break;	/* USCI B0 RX/TX */
#endif
#ifdef USCIA1_RXTX_VECTOR
        case USCIA1_RXTX_VECTOR/2: UCA1IE |= UCRXIE; break;	/* USCI A1 RX/TX */
#endif
#ifdef USCIB1_RXTX_VECTOR
        case USCIB1_RXTX_VECTOR/2: UCB1IE |= UCRXIE; break;	/* USCI B1 RX/TX */
#endif
#ifdef USCIA2_RXTX_VECTOR
        case USCIA2_RXTX_VECTOR/2: UCA2IE |= UCRXIE; break;	/* USCI A2 RX/TX */
#endif
#ifdef USCIB2_RXTX_VECTOR
        case USCIB2_RXTX_VECTOR/2: UCB2IE |= UCRXIE; break;	/* USCI B2 RX/TX */
#endif
#ifdef USCIA3_RXTX_VECTOR
        case USCIA3_RXTX_VECTOR/2: UCA3IE |= UCRXIE; break;	/* USCI A3 RX/TX */
#endif
#ifdef USCIB3_RXTX_VECTOR
        case USCIB3_RXTX_VECTOR/2: UCB3IE |= UCRXIE; break;	/* USCI B3 RX/TX */
#endif

/*
 * Timers.
 */
#ifdef TIMERA1_VECTOR
        case TIMERA1_VECTOR/2: TACCTL1 |= CCIE; break;		/* Timer A CC1-2, TA */
#endif
#ifdef TIMERA0_VECTOR
        case TIMERA0_VECTOR/2: TACCTL0 |= CCIE; break;		/* Timer A CC0 */
#endif
#ifdef TIMERB1_VECTOR
        case TIMERB1_VECTOR/2: TBCCTL1 |= CCIE; break;		/* Timer B 1-7 */
#endif
#ifdef TIMERB0_VECTOR
        case TIMERB0_VECTOR/2: TBCCTL0 |= CCIE; break;		/* Timer B 0 */
#endif
#ifdef TIMER1_A1_VECTOR
        case TIMER1_A1_VECTOR/2:				/* Timer1_A3 CC1-2, TA1 */
		if (TA1CCTL1 & CM_3) TA1CCTL1 |= CCIE;
		if (TA1CCTL2 & CM_3) TA1CCTL2 |= CCIE;
		break;
#endif
#ifdef TIMER1_A0_VECTOR
        case TIMER1_A0_VECTOR/2: TA1CCTL0 |= CCIE; break;	/* Timer1_A3 CC0 */
#endif
#ifdef TIMER0_A1_VECTOR
        case TIMER0_A1_VECTOR/2: TA0CCTL1 |= CCIE; break;	/* Timer0_A5 CC1-4, TA0 */
#endif
#ifdef TIMER0_A0_VECTOR
        case TIMER0_A0_VECTOR/2: TA0CCTL0 |= CCIE; break;	/* Timer0_A5 CC0 */
#endif
#ifdef TIMER0_B1_VECTOR
        case TIMER0_B1_VECTOR/2: TB0CCTL1 |= CCIE; break;	/* Timer_B7 CC1-6, TB */
#endif
#ifdef TIMER0_B0_VECTOR
        case TIMER0_B0_VECTOR/2: TB0CCTL0 |= CCIE; break;	/* Timer_B7 CC0 */
#endif

/*
 * Others.
 */
#ifdef ADC12_VECTOR
        case ADC12_VECTOR/2: ADC12IE = _msp430_adc12ie; break;	/* ADC */
#endif
#ifdef WDT_VECTOR
        case WDT_VECTOR/2: IE1 |= WDTIE; break;			/* Watchdog Timer */
#endif
#ifdef COMPARATORA_VECTOR
        case COMPARATORA_VECTOR/2: CACTL1  |= CAIE; break;	/* Comparator A */
#endif
#ifdef NMI_VECTOR
        case NMI_VECTOR/2: break;				/* Non-maskable */
#endif
	}
}

/*
 * The interrupt handler pattern.
 */
#define HANDLE(n,mask)\
void __attribute__ ((naked, interrupt(n))) \
_intr##n (void) \
{\
	SAVE_REGS ();\
	mask; /* disable the interrupt, avoiding loops */\
	asm volatile ("mov %0, r15" : : "i" (&mutex_irq [n/2]));\
	asm volatile ("jmp _irq_handler_");\
}

/*
 * I/O ports.
 */
#ifdef PORT1_VECTOR
HANDLE (PORT1_VECTOR, P1IFG = P1IE = 0);	/* Port 1 */
#endif
#ifdef PORT2_VECTOR
HANDLE (PORT2_VECTOR, P2IFG = P2IE = 0);	/* Port 2 */
#endif

/*
 * UARTs.
 */
#ifdef USART1TX_VECTOR
HANDLE (USART1TX_VECTOR, (U1IE &= ~UTXIE1, UTCTL1 |= TXEPT));	/* USART 1 Transmit */
#endif
#ifdef USART1RX_VECTOR
HANDLE (USART1RX_VECTOR, U1IE &= ~URXIE1);			/* USART 1 Receive */
#endif
#ifdef USART0TX_VECTOR
HANDLE (USART0TX_VECTOR, (U0IE &= ~UTXIE0, UTCTL0 |= TXEPT));	/* USART 0 Transmit */
#endif
#ifdef USART0RX_VECTOR
HANDLE (USART0RX_VECTOR, U0IE &= ~URXIE0);			/* USART 0 Receive */
#endif
#ifdef USCIAB0TX_VECTOR
HANDLE (USCIAB0TX_VECTOR, IE2 &= ~UCA0TXIE);			/* USCI A0/B0 Transmit */
#endif
#ifdef USCIAB0RX_VECTOR
HANDLE (USCIAB0RX_VECTOR, IE2 &= ~UCA0RXIE);			/* USCI A0/B0 Receive */
#endif
#ifdef USCIAB1TX_VECTOR
HANDLE (USCIAB1TX_VECTOR, IE2 &= ~UCA1TXIE);			/* USCI A1/B1 Transmit */
#endif
#ifdef USCIAB1RX_VECTOR
HANDLE (USCIAB1RX_VECTOR, IE2 &= ~UCA1RXIE);			/* USCI A1/B1 Receive */
#endif
#ifdef USCIA0_RXTX_VECTOR
HANDLE (USCIA0_RXTX_VECTOR, UCA0IE &= ~(UCRXIE | UCTXIE));	/* USCI A0 RX/TX */
#endif
#ifdef USCIB0_RXTX_VECTOR
HANDLE (USCIB0_RXTX_VECTOR, UCB0IE &= ~(UCRXIE | UCTXIE));	/* USCI B0 RX/TX */
#endif
#ifdef USCIA1_RXTX_VECTOR
HANDLE (USCIA1_RXTX_VECTOR, UCA1IE &= ~(UCRXIE | UCTXIE));	/* USCI A1 RX/TX */
#endif
#ifdef USCIB1_RXTX_VECTOR
HANDLE (USCIB1_RXTX_VECTOR, UCB1IE &= ~(UCRXIE | UCTXIE));	/* USCI B1 RX/TX */
#endif
#ifdef USCIA2_RXTX_VECTOR
HANDLE (USCIA2_RXTX_VECTOR, UCA2IE &= ~(UCRXIE | UCTXIE));	/* USCI A2 RX/TX */
#endif
#ifdef USCIB2_RXTX_VECTOR
HANDLE (USCIB2_RXTX_VECTOR, UCB2IE &= ~(UCRXIE | UCTXIE));	/* USCI B2 RX/TX */
#endif
#ifdef USCIA3_RXTX_VECTOR
HANDLE (USCIA3_RXTX_VECTOR, UCA3IE &= ~(UCRXIE | UCTXIE));	/* USCI A3 RX/TX */
#endif
#ifdef USCIB3_RXTX_VECTOR
HANDLE (USCIB3_RXTX_VECTOR, UCB3IE &= ~(UCRXIE | UCTXIE));	/* USCI B3 RX/TX */
#endif

/*
 * Timers.
 */
#ifdef TIMERA1_VECTOR
HANDLE (TIMERA1_VECTOR, TACCTL1 &= ~CCIE);	/* Timer A CC1-2, TA */
#endif
#ifdef TIMERA0_VECTOR
HANDLE (TIMERA0_VECTOR, TACCTL0 &= ~CCIE);	/* Timer A CC0 */
#endif
#ifdef TIMERB1_VECTOR
HANDLE (TIMERB1_VECTOR, TBCCTL1 &= ~CCIE);	/* Timer B 1-7 */
#endif
#ifdef TIMERB0_VECTOR
HANDLE (TIMERB0_VECTOR, TBCCTL0 &= ~CCIE);	/* Timer B 0 */
#endif
#ifdef TIMER1_A1_VECTOR
HANDLE (TIMER1_A1_VECTOR, (TA1CCTL1 &= ~CCIE,
			   TA1CCTL2 &= ~CCIE));	/* Timer1_A3 CC1-2, TA1 */
#endif
#ifdef TIMER1_A0_VECTOR
HANDLE (TIMER1_A0_VECTOR, TA1CCTL0 &= ~CCIE);	/* Timer1_A3 CC0 */
#endif
#ifdef TIMER0_A1_VECTOR
HANDLE (TIMER0_A1_VECTOR, TA0CCTL1 &= ~CCIE);	/* Timer0_A5 CC1-4, TA0 */
#endif
#ifdef TIMER0_A0_VECTOR
HANDLE (TIMER0_A0_VECTOR, TA0CCTL0 &= ~CCIE);	/* Timer0_A5 CC0 */
#endif
#ifdef TIMER0_B1_VECTOR
HANDLE (TIMER0_B1_VECTOR, TB0CCTL1 &= ~CCIE);	/* Timer_B7 CC1-6, TB */
#endif
#ifdef TIMER0_B0_VECTOR
HANDLE (TIMER0_B0_VECTOR, TB0CCTL0 &= ~CCIE);	/* Timer_B7 CC0 */
#endif

/*
 * Others.
 */
#ifdef ADC12_VECTOR
HANDLE (ADC12_VECTOR, ADC12IE = 0);		/* ADC */
#endif
#ifdef WDT_VECTOR
HANDLE (WDT_VECTOR, IE1 &= ~WDTIE);		/* Watchdog Timer */
#endif
#ifdef COMPARATORA_VECTOR
HANDLE (COMPARATORA_VECTOR, CACTL1 &= ~CAIE);	/* Comparator A */
#endif
#ifdef NMI_VECTOR
HANDLE (NMI_VECTOR, );				/* Non-maskable */
#endif

/* --TODO--
 * ADC10_VECTOR
 * BASICTIMER_VECTOR
 * DACDMA_VECTOR
 * IO0_VECTOR
 * IO1_VECTOR
 * PORT0_VECTOR
 * TIMERPORT_VECTOR
 * UARTRX_VECTOR
 * UARTTX_VECTOR
 *
 * RTC_A_VECTOR
 * DMA_VECTOR
 * AD12_A_VECTOR
 * USER_NMI_VECTOR
 */
