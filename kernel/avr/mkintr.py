#!/usr/bin/python
#
# Generate uOS interrupt handlers for AVR microcontrollers.
# Copyright (GPL) 2009 Serge Vakulenko <serge@vak.ru>
#
import sys, string

if len(sys.argv) != 2:
	print "Usage: mkintr.py interrupt.cfg"
	sys.exit (1)

cpu = ""
lnum = 0
cpus = {}
maxirq = 0

#
# Read a list of mask bits for all interrupt sources.
#
filename = sys.argv[1]
sys.stdin = open (filename, "r")
while 1:
	line = sys.stdin.readline ()
	if not line:
		# End of file
		break
	lnum = lnum + 1;

	words = string.split (line)
	if words == [] or words[0][0] == '#':
		# Skip empty lines and comments
		continue

	if line[0] != ' ' and line[0] != '\t':
		# Line starts from column 1: CPU model
		cpu = words[0]
		cpus [cpu] = {}
		continue

	if cpu == "":
		print "Line %d: unknown CPU model" % lnum
		continue

	if len (words) < 3:
		print "Line %d: incorrect data format" % lnum
		continue

	irq = string.atoi (words[0])
	register = words[1]
	bit = words[2]

	#print cpu, irq, register, bit
	cpus [cpu] [irq] = (register, bit)
	if irq > maxirq:
		maxirq = irq

#
# Create a C file with uOS interrupt handlers for a given CPU.
#
def generate_cpu (cpu, data):
	fd = open (cpu + ".c", "w")
	print >>fd, "/* uOS interrupt handlers for %s." % cpu
	print >>fd, " * This file was generated by script 'mkintr.py' from data '%s'." % filename
	print >>fd, " * Do not edit it manually! */"
	print >>fd
	for irq in range(maxirq+1):
		if irq not in data.keys():
			continue;

		(register, bit) = data[irq]
		if bit[0] == '-':
			bit = bit[1:]
		print >>fd, "\tHANDLE (%d, clearb_r30 (%s, %s))" % (irq, bit, register)

	print >>fd
	print >>fd, "void arch_intr_allow (int irq)"
	print >>fd, "{"
	print >>fd, "\tswitch ((unsigned char) irq) {"
	for irq in range(maxirq+1):
		if irq not in data.keys():
			continue;

		(register, bit) = data[irq]
		if bit[0] == '-':
			bit = bit[1:]
			print >>fd, "\tcase %d: break;" % irq
			continue;

		print >>fd, "\tcase %d: setb (%s, %s); break;" % (irq, bit, register)
	print >>fd, "\t}"
	print >>fd, "}"
	fd.close()

#
# Generate C files for every CPU.
#
cpu_names = cpus.keys()
cpu_names.sort()
for cpu in cpu_names:
	generate_cpu (cpu, cpus[cpu])

sys.exit (0)
